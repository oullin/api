# Caddy will automatically provision a Let's Encrypt certificate.

oullin.io {
	# Enable compression to reduce bandwidth usage.
	encode gzip zstd

	# Add security-related headers to protect against common attacks.
	# 	- Strict-Transport-Security: Enable HSTS to ensure browsers only connect via HTTPS.
	# 	- X-Frame-Options: Prevent clickjacking attacks.
	# 	- X-Content-Type-Options: Prevent content type sniffing.
	# 	- Referrer-Policy: Enhances user privacy.
	header {
		Strict-Transport-Security "max-age=31536000;"
		X-Frame-Options "SAMEORIGIN"
		X-Content-Type-Options "nosniff"
		Referrer-Policy "strict-origin-when-cross-origin"
	}

	log {
		output file /var/log/caddy/oullin.io.log {
			roll_size 10mb # Rotate logs after they reach 10MB
			roll_keep 5 # Keep the last 5 rotated log files
		}

		format json
	}

	# --- API: block the protected path on the public listener.
	@protected_public path /api/generate-signature*
	handle @protected_public {
		respond 403
	}

	@preflight {
		method OPTIONS
		header Origin *
	}

	# --- API handler.
	# 	- Reverse-proxy all requests to the Go API, forwarding Host + auth headers.
	#	- to: Tell Caddy which upstream to send to.
	#	- header_up: Preserve the original Host header.
	#	- header_up X-*: Forward the client headers.
	handle_path /api/* {
		header {
			Access-Control-Allow-Origin "https://oullin.io"
			Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS"
			Access-Control-Allow-Headers "X-API-Key, X-API-Username, X-API-Signature, X-API-Timestamp, X-API-Nonce, X-Request-ID, Content-Type, User-Agent, If-None-Match, X-API-Intended-Origin"
			Access-Control-Expose-Headers "ETag, X-Request-ID"
		}

		handle @preflight {
			# Reflect the Origin back so it's always allowed
			header Access-Control-Allow-Origin "{http.request.header.Origin}"
			header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS"
			header Access-Control-Allow-Headers "X-API-Key, X-API-Username, X-API-Signature, X-API-Timestamp, X-API-Nonce, X-Request-ID, Content-Type, User-Agent, If-None-Match, X-API-Intended-Origin"
			header Access-Control-Max-Age "86400"
			respond 204
		}

		reverse_proxy api:8080 {
			header_up Host {host}
			header_up X-API-Username {http.request.header.X-API-Username}
			header_up X-API-Key {http.request.header.X-API-Key}
			header_up X-API-Signature {http.request.header.X-API-Signature}
			header_up X-API-Timestamp {http.request.header.X-API-Timestamp}
			header_up X-API-Nonce {http.request.header.X-API-Nonce}
			header_up X-Request-ID {http.request.header.X-Request-ID}
			header_up Content-Type {http.request.header.Content-Type}
			header_up User-Agent {http.request.header.User-Agent}
			header_up If-None-Match {http.request.header.If-None-Match}
			header_up X-API-Intended-Origin {http.request.header.X-API-Intended-Origin}

			transport http {
				dial_timeout 10s
				response_header_timeout 30s
			}
		}
	}

	# --- Default handler.
	# 	- Route all other traffic to the Vue frontend app.
	#	- `web` is the Vue app's container name.
	# 	- source: https://github.com/oullin/web
	handle {
		reverse_proxy web:80
	}
}

# INTERNAL mTLS entrypoint for the single protected path
:8443 {
    tls /etc/caddy/mtls/server.pem /etc/caddy/mtls/server.key {
		client_auth {
			mode require_and_verify
			# The client must present a cert trusted by the CA
			trust_pool file /etc/caddy/mtls/ca.pem
		}
	}

    encode gzip zstd

    handle_path /api/generate-signature* {
       reverse_proxy api:8080
    }

    handle {
       respond 403
    }
}
